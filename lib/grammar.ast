TARGET = ocaml
PRELUDE = {
  open! Tokens
  open! Ast
  open! Span
}
ENTRY = program

token_Ident = string
token_String = string
token_StringFragment = string
token_Int = {int64}

program: { item list }
  | FUNC program { Func v0 :: v1 }
  | { [] }

FUNC: { func node }
  | Toaster Ident HAPPINESS ARG_LIST RETURN_TYPE BLOCK
      { no_loc (v1, v2, v3, v4, v5) }

HAPPINESS: { bool }
  | Happy { true }
  | Sad { false }

ARG_LIST: { arg list }
  | ARG_LIST_ { v0 }
  # | ARG_LIST_ Comma { v0 }
  # TODO(asterisk): figure out how to resolve this shift/reduce conflict
  # maybe just give option to always reduce MORE_ARGS if possible?

ARG_LIST_: { arg list }
  | { [] }
  | Ident Colon TYPE { [v0, v2] }
  | Ident Colon TYPE MORE_ARGS { (v0, v2)::v3 }

MORE_ARGS: { arg list }
  | Comma Ident Colon TYPE { [] }
  | Comma Ident Colon TYPE MORE_ARGS { (v1, v3)::v4 }
  # v0    v1    v2    v3   v4

TYPE: { ty }
  | OpenParen CloseParen { TTuple [] }
  | Ident { TVar v0 }

RETURN_TYPE: { ty }
  | Arrow TYPE { v1 }
  | { TTuple [] }

BLOCK: { block }
  | OpenBrace STATEMENTS CloseBrace { v1 }

STATEMENTS: { stmt node list }
  | STATEMENT STATEMENTS { v0 :: v1 }
  | { [] }

STATEMENT: { stmt node }
  | Return Semicolon { no_loc @@ SReturn (no_loc @@ ETuple []) }


# TODO: implement grammar
